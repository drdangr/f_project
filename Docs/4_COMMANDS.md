### Загальний устрій

Файл `commands.py` реалізує весь «каталог» команд консольного помічника: зберігає реєстр, декларативно реєструє обробники та містить бізнес-логіку для контактів, нотаток та системних команд. Базова ідея — кожна команда представлена функцією, яка приймає список рядкових аргументів та об'єкт `Storage`, а результатом повертає читабельну відповідь. Набір допоміжних декораторів позбавляє від рутинного коду: автоматична реєстрація, обробка помилок та автозбереження.

### Реєстр команд

- Клас `CommandRegistry` тримає чотири структури: `handlers`, `help`, `sections` та `min_args`, де ключ — нормалізоване ім'я команди. Метод `register()` повертає декоратор, який закріплює функцію, її опис, секцію та мінімальну кількість аргументів, забороняючи дублі (*RuntimeError* при повторній реєстрації). Метод `validate_args()` перевіряє кількість аргументів до виклику handler. Завдяки методу `resolve()` CLI може перевірити, чи існує команда, а `help_text()` формує загальний список для `help`.  
```18:97:commands.py
class CommandRegistry:
    ...
```

- Глобальний екземпляр `REG` використовується всім модулем. Це єдина точка реєстрації, тому список доступних команд централізований.  
```107:107:commands.py
REG = CommandRegistry()
```

### CommandRegistry: призначення та устрій. Детальний розбір.

`CommandRegistry` — невеликий сервіс-клас, який зберігає всі команди CLI, їх короткі описи та належність до розділів. Він забезпечує реєстрацію, пошук та видачу підказок, а також допомагає іншим частинам програми дізнатися, які команди доступні.

```18:25:commands.py
class CommandRegistry:
    """Реєстр команд зі суворим зіставленням за іменем."""

    def __init__(self) -> None:
        self._handlers: Dict[str, Handler] = {}
        self._help: Dict[str, str] = {}
        self._sections: Dict[str, str] = {}
        self._min_args: Dict[str, int] = {}
```

- При створенні (`__init__`) клас заводить чотири словники:
  - `_handlers`: ім'я команди → функція-обробник (`Handler`).
  - `_help`: ім'я команди → рядок довідки (короткий опис для `help`).
  - `_sections`: ім'я команди → назва розділу, в якому команда відображається при виклику `help`.
  - `_min_args`: ім'я команди → мінімальна кількість обов'язкових аргументів.

#### register()

```27:45:commands.py
    def register(
        self, name: str, *, help: str = "", section: str | None = None, min_args: int = 0
    ) -> Callable[[Handler], Handler]:
        """Зареєструвати команду."""

        def decorator(func: Handler) -> Handler:
            key = name.strip().lower()
            if key in self._handlers:
                raise RuntimeError(f"Duplicate command: {name}")
            self._handlers[key] = func
            self._help[key] = help.strip()
            self._min_args[key] = min_args
            normalized_section = section.strip() if section else DEFAULT_SECTION
            if normalized_section not in SECTION_ORDER[:-1]:
                normalized_section = DEFAULT_SECTION
            self._sections[key] = normalized_section
            return func

        return decorator
```

- Метод повертає декоратор, яким обгортають функції-обробники.
- Приводить ім'я до нижнього регістру та обрізає пробіли — реєстрація/пошук регістронезалежні.
- Забороняє дублі імен: при повторному `register("add")` одразу викидає `RuntimeError`.
- Зберігає обробник, опис, розділ та мінімальну кількість аргументів у словники, потім повертає саму функцію (щоб декоратор не змінював поведінку).
- Параметр `section` необов'язковий; якщо він не вказаний або не потрапляє в допустимий список (`SECTION_ORDER`), команда опиниться в розділі «Інше».
- Параметр `min_args` (за замовчуванням 0) визначає мінімальну кількість аргументів, які потрібні команді. Валідація відбувається автоматично в `cli.py` перед викликом handler.

#### resolve()

```47:51:commands.py
    def resolve(self, name: str) -> Optional[str]:
        """Повернути точне ім'я команди, якщо воно зареєстроване."""
        k = name.strip().lower()
        return k if k in self._handlers else None
```

- Нормалізує ім'я та перевіряє, чи є така команда.
- Потрібен, наприклад, для `help foo`: CLI може спочатку дізнатися, чи зареєстрована команда, перш ніж намагатися викликати обробник.
- Повертає нормалізоване ім'я або `None`.

#### validate_args()

```56:67:commands.py
    def validate_args(self, cmd_name: str, args: List[str]) -> None:
        """Перевірити кількість аргументів для команди."""
        key = cmd_name.strip().lower()
        min_required = self._min_args.get(key, 0)
        
        if len(args) < min_required:
            help_text = self._help.get(key, "")
            if help_text:
                raise IndexError(f"Not enough arguments. {help_text}")
            else:
                raise IndexError(f"Command '{cmd_name}' requires at least {min_required} argument(s)")
```

- Перевіряє, чи достатньо аргументів передано для команди.
- Якщо аргументів менше, ніж `min_args`, викидає `IndexError` з текстом довідки.
- Викликається в `cli.py` автоматично перед викликом handler.

#### handler()

```52:55:commands.py
    def handler(self, key: str) -> Handler:
        """Отримати обробник за ключем."""
        return self._handlers[key]
```

- Повертає саму функцію-обробник.
- Передбачається, що `key` валідний (зазвичай перед отриманням викликається `resolve`); інакше буде `KeyError`.

#### all_commands()

```68:71:commands.py
    def all_commands(self) -> List[str]:
        """Отримати список всіх команд."""
        return sorted(self._handlers.keys())
```

- Повертає відсортований список всіх зареєстрованих імен.
- Використовується для виведення довідки та автодоповнення (якщо потрібно).

#### get_help()

```72:76:commands.py
    def get_help(self, name: str) -> str:
        """Отримати довідку команди за її іменем."""
        key = name.strip().lower()
        return self._help.get(key, "")
```

- Повертає опис, який було передано при реєстрації, або порожній рядок, якщо команда не знайдена/опис не заданий.

#### help_text()

```77:98:commands.py
    def help_text(self) -> str:
        """Повернути компактний текст довідки."""
        groups: Dict[str, List[str]] = {section: [] for section in SECTION_ORDER}
        for cmd in self.all_commands():
            section = self._sections.get(cmd, DEFAULT_SECTION)
            groups.setdefault(section, []).append(cmd)

        lines = ["Доступные команды:"]
        for section in SECTION_ORDER:
            cmds = groups.get(section, [])
            if not cmds:
                continue
            lines.append("")
            lines.append(f"{section}:")
            for cmd in cmds:
                desc = self._help.get(cmd, "")
                lines.append(f"  - {cmd}: {desc}")

        lines.append("")
        lines.append("Для деталей щодо конкретної команди використовуйте: help <command>")
        return "\n".join(lines)
```

- Формує багаторядковий текст, де команди виводяться блоками: «Phonebook», «Notes», «System» та «Інше».
- Секції йдуть у фіксованому порядку (`SECTION_ORDER`), але порожні блоки пропускаються.
- Всередині блоку перераховуються самі команди з описом; фінальна підказка нагадує про `help <command>`.
- У модулі оголошені константи `SECTION_PHONEBOOK`, `SECTION_NOTES`, `SECTION_SYSTEM`, `SECTION_ORDER` та `DEFAULT_SECTION`. Вони задають зрозумілі назви розділів та гарантують, що команди без секції опиняться в останньому блоці — «Інше».

### Життєвий цикл

1. Десь у `commands.py` оголошують глобальний `REG = CommandRegistry()`.
2. Кожна команда оформлена функцією з декораторами `@REG.register("ім'я", help="...", section="...", min_args=N)`, опціонально `@input_error`, `@mutating`.
3. CLI-парсер отримує рядок від користувача, визначає ім'я команди, нормалізує його та викликає:
   - `REG.resolve(name)` → перевірка існування команди.
   - `REG.validate_args(name, args)` → автоматична перевірка кількості аргументів.
   - `REG.handler(key)` → отримання самої функції.
4. Після виконання обробника CLI показує рядок-результат користувачу.
5. Команда `help` використовує `REG.help_text()` або `REG.get_help()` для деталей.

Завдяки цьому клас служить «центральною адресною книгою» всіх команд: реєстрація автоматизує додавання, запобігає дублям, валідує кількість аргументів, а отримання/довідка відбуваються через єдиний API.

### Загальні декоратори

- `input_error` — ловить типові винятки та перетворює їх на дружні повідомлення.  
  * `KeyError` → «Not found: ...» (немає контакту/нотатки),  
  * `ValueError` → «Value error: ...»,  
  * `IndexError` → текст usage (викидається `validate_args()`) або «Not enough arguments»,  
  * інші → «Error: ...».  
  Завдяки цьому бізнес-логіка може сміливо викидати винятки, не турбуючись про форматування відповіді.  
```110:144:commands.py
def input_error(func):
    ...
```

- `mutating` — обгортає команди, які змінюють стан. Після успішного виконання викликає `save_storage(storage)`; якщо відповідь починається з `Error`, або дорівнює `__EXIT__`, збереження пропускається, запобігаючи хибним записам.  
```147:177:commands.py
def mutating(func):
    ...
```

**Важливо:** Функція `require_args()` була видалена на користь централізованої валідації через `REG.validate_args()`. Тепер перевірка кількості аргументів відбувається автоматично в `cli.py` на основі параметра `min_args` при реєстрації команди.

### Команди для контактів

- `cmd_add` додає контакт або телефон. Зареєстрована з `min_args=1` (потребує хоча б ім'я). Перевіряє, чи існує запис; якщо ні — створює `Record(Name(...))`, додає перший телефон (якщо переданий) та зберігає. Якщо контакт вже є, але телефон не вказаний, повідомляє про необхідність номера, а при повторюваному телефоні не дублює його.  
```185:216:commands.py
@REG.register("add", help='Usage: add "Name" [0123456789]', section=SECTION_PHONEBOOK, min_args=1)
...
```
- Усі обробники в цьому розділі реєструються з `section=SECTION_PHONEBOOK` та відповідним `min_args`, тому в довідці підсумковий список потрапляє в блок «Phonebook», а валідація аргументів відбувається автоматично.

- `cmd_change`, `cmd_phone`, `cmd_all`, `cmd_add_birthday`, `cmd_show_birthday`, `cmd_birthdays` реалізують, відповідно, зміну номера, перегляд телефонів, вивантаження всіх контактів, роботу з днями народження та список майбутніх свят (за замовчуванням 7 днів вперед, з групуванням за зміщеннями Today/Tomorrow/…).

- Блок e-mail/адрес:  
  * `cmd_add_email` та `cmd_remove_email` управляють списком e-mail'ів запису; останній повертає «Email not found», якщо видаляти нічого.  
  * `cmd_set_address` зберігає адресу; `cmd_remove_address` видаляє адресу.  
  * `cmd_remove_phone` видаляє телефон з контакту.  
  * `cmd_find` виконує пошуковий запит по всіх полях, використовуючи `contacts.search`.  
  * `cmd_delete_contact` видаляє запис, якщо метод `remove_record` повернув `True`.

### Команди для нотаток

- `cmd_add_note` створює нотатку з обов'язковим текстом (порожній заборонений). Зареєстрована з `min_args=2` (назва та текст).
- `cmd_list_notes` виводить усі нотатки з сортуванням по `title` (дефолт) або `created`, форматуючи дату та список тегів (якщо тегів немає — `(no tags)`). Не потребує аргументів (`min_args=0`).
- `cmd_find_note` та `cmd_find_tag` шукають по тексту та тегу (`min_args=1`), повертаючи перелік підхожих нотаток або «No results.».

- `cmd_edit_note` замінює текст нотатки (`min_args=2`); порожній текст блокується `ValueError`.  
- `cmd_tag_add`, `cmd_tag_remove`, `cmd_delete_note` дозволяють управляти тегами та видаляти нотатку, повідомляючи про успіх або відсутність потрібного тега/нотатки (відповідно `min_args=2`, `min_args=2`, `min_args=1`).

```418:556:commands.py
@REG.register("add-note", help='Usage: add-note "Title" text...', section=SECTION_NOTES, min_args=2)
...
```
- Команди по нотатках отримують `section=SECTION_NOTES` та відповідний `min_args`, і `help` виводить їх під заголовком «Notes».

### Системні команди

- `cmd_hello` повертає привітання.  
- `cmd_help` без аргументів видає загальний список через `REG.help_text()`, а з ім'ям команди — опис конкретного обробника або «Unknown command».  
- `cmd_exit` реєструється як `close` та `exit`, повертає спеціальний маркер `__EXIT__`, який CLI сприймає як сигнал завершення без збереження.  
- `cmd_version` підвантажує константи `APP_NAME`, `APP_VERSION` та шлях `STORAGE_FILE`, формуючи рядок виду `personal_assistant_cli v1.0.0 | data: ...`.  

```563:596:commands.py
@REG.register("hello", ...)
...
```
- Системні команди використовують `section=SECTION_SYSTEM`. Якщо якась нова команда не вкаже розділ або задасть незнайоме значення, реєстр відправить її в «Інше» (це `DEFAULT_SECTION`).

### Підсумкова схема роботи

1. CLI парсить ввід у команду та аргументи.
2. CLI викликає `REG.validate_args()` для перевірки кількості аргументів (на основі `min_args` при реєстрації).
3. CLI отримує обробник через `REG.handler()`.
4. Обробник майже завжди обгорнутий в `@input_error`, а всі модифікуючі — ще й в `@mutating`.  
5. Логіка звертається до об'єкта `Storage`, маніпулюючи моделями (`Record`, `Note` тощо).  
6. Результуючий рядок повертається в інтерфейс; при успішних змінах стан автоматично серіалізується.

Такий устрій робить файл `commands.py` центром бізнес-логіки: додавання нової команди зводиться до написання функції та прикрашання її потрібними декораторами (включаючи `min_args` для автоматичної валідації), після чого команда автоматично з'являється в `help` та працює із загальною системою обробки помилок та збереження даних.