### Общее устройство

Файл `commands.py` реализует весь «каталог» команд консольного помощника: хранит реестр, декларативно регистрирует обработчики и содержит бизнес-логику для контактов, заметок и системных команд. Базовая идея — каждая команда представлена функцией, которая принимает список строковых аргументов и объект `Storage`, а результатом возвращает человекочитаемый ответ. Набор вспомогательных декораторов избавляет от рутинного кода: автоматическая регистрация, обработка ошибок и автосохранение.

### Реестр команд

- Класс `CommandRegistry` держит две структуры: `handlers` и `help`, где ключ — нормализованное имя команды. Метод `register()` возвращает декоратор, который закрепляет функцию и её описание, запрещая дубли (*RuntimeError* при повторной регистрации). Благодаря методу `resolve()` CLI может проверить, существует ли команда, а `help_text()` формирует общий список для `help`.  
```19:64:commands.py
class CommandRegistry:
    ...
```

- Глобальный экземпляр `REG` используется всем модулем. Это единственная точка регистрации, поэтому список доступных команд централизован.  
```66:66:commands.py
REG = CommandRegistry()
```

### CommandRegistry: назначение и устройство. Подробный разбор.

`CommandRegistry` — небольшой сервис-класс, который хранит все команды CLI и их краткие описания. Он обеспечивает регистрацию, поиск и выдачу подсказок, а также помогает другим частям программы узнать, какие команды доступны.

```19:63:commands.py
class CommandRegistry:
    """Реестр команд со строгим сопоставлением по имени."""

    def __init__(self) -> None:
        self._handlers: Dict[str, Handler] = {}
        self._help: Dict[str, str] = {}
```

- При создании (`__init__`) класс заводит два словаря:
  - `_handlers`: имя команды → функция-обработчик (`Handler`).
  - `_help`: имя команды → строка справки (короткое описание для `help`).

#### register()

```25:35:commands.py
    def register(self, name: str, *, help: str = "") -> Callable[[Handler], Handler]:
        """Зарегистрировать команду."""

        def decorator(func: Handler) -> Handler:
            key = name.strip().lower()
            if key in self._handlers:
                raise RuntimeError(f"Duplicate command: {name}")
            self._handlers[key] = func
            self._help[key] = help.strip()
            return func

        return decorator
```

- Метод возвращает декоратор, которым оборачивают функции-обработчики.
- Приводит имя к нижнему регистру и обрезает пробелы — регистрация/поиск регистронезависимые.
- Запрещает дубли имен: при повторном `register("add")` сразу выбрасывает `RuntimeError`.
- Сохраняет обработчик и описание в словари, затем возвращает саму функцию (чтобы декоратор не менял поведение).

#### resolve()

```38:42:commands.py
    def resolve(self, name: str) -> Optional[str]:
        """Вернуть точное имя команды, если оно зарегистрировано."""
        k = name.strip().lower()
        return k if k in self._handlers else None
```

- Нормализует имя и проверяет, есть ли такая команда.
- Нужен, например, для `help foo`: CLI может сначала узнать, зарегистрирована ли команда, прежде чем пытаться вызвать обработчик.
- Возвращает нормализованное имя или `None`.

#### handler()

```43:45:commands.py
    def handler(self, key: str) -> Handler:
        """Получить обработчик по ключу."""
        return self._handlers[key]
```

- Возвращает саму функцию-обработчик.
- Предполагается, что `key` валиден (обычно перед получением вызывается `resolve`); в противном случае будет `KeyError`.

#### all_commands()

```47:49:commands.py
    def all_commands(self) -> List[str]:
        """Получить список всех команд."""
        return sorted(self._handlers.keys())
```

- Возвращает отсортированный список всех зарегистрированных имён.
- Используется для вывода справки и автодополнения (если нужно).

#### get_help()

```51:54:commands.py
    def get_help(self, name: str) -> str:
        """Получить справку команды по её имени."""
        key = name.strip().lower()
        return self._help.get(key, "")
```

- Возвращает описание, которое было передано при регистрации, или пустую строку, если команда не найдена/описание не задано.

#### help_text()

```56:63:commands.py
    def help_text(self) -> str:
        """Вернуть компактный текст справки."""
        lines = ["Доступные команды:"]
        for k in self.all_commands():
            h = self._help.get(k, "")
            lines.append(f"  - {k}: {h}")
        lines.append("\nДля деталей по конкретной команде используйте: help <command>")
        return "\n".join(lines)
```

- Формирует многострочный текст: верхняя строчка — заголовок, далее список `команда: описание`, и заключительная подсказка про `help <command>`.
- Воспользуется `all_commands`, чтобы убедиться, что команды выведены последовательно и отсортированы.

### Жизненный цикл

1. Где-то в `commands.py` объявляют глобальный `REG = CommandRegistry()`.
2. Каждая команда оформлена функцией с декораторами `@REG.register("имя", help="...")`, опционально `@input_error`, `@mutating`.
3. CLI-парсер получает строку от пользователя, определяет имя команды, нормализует его и вызывает:
   - `REG.resolve(name)` → проверка.
   - `REG.handler(key)` → получение самой функции.
4. После выполнения обработчика CLI показывает строку-результат пользователю.
5. Команда `help` использует `REG.help_text()` или `REG.get_help()` для подробностей.

Благодаря этому класс служит «центральной адресной книгой» всех команд: регистрация автоматизирует добавление, предотвращает дубли, а извлечение/справка происходят через единый API.

### Общие декораторы

- `require_args()` — простая проверка на минимальное число аргументов, выбрасывает `IndexError` с читаемым usage-текстом, что затем подхватывает декоратор ошибок.  
```69:75:commands.py
def require_args(...):
    ...
```

- `input_error` — ловит типичные исключения и преобразует их в дружелюбные сообщения.  
  * `KeyError` → «Not found: ...» (нет контакта/заметки),  
  * `ValueError` → «Value error: ...»,  
  * `IndexError` → текст usage или дефолтное «Not enough arguments»,  
  * прочие → «Error: ...».  
  Благодаря этому бизнес-логика может смело бросать исключения, не заботясь о форматировании ответа.  
```77:111:commands.py
def input_error(func):
    ...
```

- `mutating` — оборачивает команды, которые меняют состояние. После успешного выполнения вызывает `save_storage(storage)`; если ответ начинается с `Error`, либо равен `__EXIT__`, сохранение пропускается, предотвращая ложные записи.  
```114:144:commands.py
def mutating(func):
    ...
```

### Команды для контактов

- `cmd_add` добавляет контакт или телефон. Проверяет, существует ли запись; если нет — создаёт `Record(Name(...))`, добавляет первый телефон (если передан) и сохраняет. Если контакт уже есть, но телефон не указан, сообщает о необходимости номера, а при повторяющемся телефоне не дублирует его.  
```152:179:commands.py
@REG.register("add", ...)
...
```

- `cmd_change`, `cmd_phone`, `cmd_all`, `cmd_add_birthday`, `cmd_show_birthday`, `cmd_birthdays` реализуют, соответственно, смену номера, просмотр телефонов, выгрузку всех контактов, работу с днями рождения и список грядущих праздников (по умолчанию 7 дней вперёд, с группировкой по смещениям Today/Tomorrow/…).

- Блок e-mail/адресов:  
  * `cmd_add_email` и `cmd_remove_email` управляют списком e-mail’ов записи; последний возвращает «Email not found», если удалить нечего.  
  * `cmd_set_address` сохраняет адрес.  
  * `cmd_find` выполняет поисковый запрос по всем полям, используя `contacts.search`.  
  * `cmd_delete_contact` удаляет запись, если метод `remove_record` вернул `True`.

### Команды для заметок

- `cmd_add_note` создаёт заметку с обязательным текстом (пустой запрещён).  
- `cmd_list_notes` выводит все заметки с сортировкой по `title` (дефолт) или `created`, форматируя дату и список тегов (если тегов нет — `(no tags)`).  
- `cmd_find_note` и `cmd_find_tag` ищут по тексту и тегу, возвращая перечень подходящих заметок или «No results.».

- `cmd_edit_note` заменяет текст заметки; пустой текст блокируется `ValueError`.  
- `cmd_tag_add`, `cmd_tag_remove`, `cmd_delete_note` позволяют управлять тегами и удалять заметку, сообщая об успехе или отсутствии нужного тега/заметки.

```308:404:commands.py
@REG.register("add-note", ...)
...
```

### Системные команды

- `cmd_hello` возвращает приветствие.  
- `cmd_help` без аргументов выдаёт общий список через `REG.help_text()`, а с именем команды — описание конкретного обработчика или «Unknown command».  
- `cmd_exit` регистрируется как `close` и `exit`, возвращает специальный маркер `__EXIT__`, который CLI воспринимает как сигнал завершения без сохранения.  
- `cmd_version` подгружает константы `APP_NAME`, `APP_VERSION` и путь `STORAGE_FILE`, формируя строку вида `personal_assistant_cli v1.0.0 | data: ...`.  

```412:444:commands.py
@REG.register("hello", ...)
...
```

### Итоговая схема работы

1. CLI парсит ввод в команду и аргументы, спрашивает у `REG` обработчик.  
2. Обработчик почти всегда обёрнут в `@input_error`, а все модифицирующие — ещё и в `@mutating`.  
3. Логика обращается к объекту `Storage`, манипулируя моделями (`Record`, `Note` и т.д.).  
4. Результирующая строка возвращается в интерфейс; при успешных изменениях состояние автоматически сериализуется.

Такое устройство делает файл `commands.py` центром бизнес-логики: добавление новой команды сводится к написанию функции и украшению её нужными декораторами, после чего команда автоматически появляется в `help` и работает с общей системой обработки ошибок и сохранения данных.