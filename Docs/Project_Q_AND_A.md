# Полная Q&A-шпаргалка по проекту

---

# I. Архитектура (6 вопросов)

### **1. Зачем вы разбили проект на отдельные модули?**

Чтобы снизить связность и сделать код читаемым. Каждый модуль отвечает за свою часть логики: модели — за данные, команды — за бизнес-логику, CLI — за ввод/вывод, storage — за сохранение. Это облегчает поддержку и позволяет любому разработчику быстро ориентироваться.

### **2. Главное достоинство архитектуры?**

Компоненты независимы. Например, можно заменить pickle-хранилище на JSON или SQLite, не меняя команды. Или переписать CLI на веб-интерфейс — и остальная логика продолжит работать.

### **3. Какие зависимости между модулями?**

Зависимости строго однонаправленные: CLI → Registry → Commands → Models → Storage → Config. Это исключает циклические импорты и делает систему предсказуемой.

### **4. Почему CLI такой тонкий?**

CLI занимается только парсингом строки и выводом результата. Логика вынесена в команды, а правила работы с данными — в модели. Такой подход делает интерфейс легко заменяемым.

### **5. Где точка расширения приложения?**

Команды. Любую новую функцию — от экспорта данных до SMS-напоминаний — можно реализовать одной функцией с декоратором. Остальная архитектура уже готова это поддержать.

### **6. Как бы вы добавили Telegram-бота?**

Я бы оставил команды и модели без изменений. Бот просто принимает текст пользователя, парсит аргументы и вызывает те же функции команд. Архитектура позволяет это без переделок.

---

# II. CommandRegistry (15 вопросов)

### **7. Как регистрируются команды?**

Через `@REG.register`. При регистрации имя команды добавляется в словарь реестра как ключ, а ссылка на функцию — как значение. Это позволяет обрабатывать команды динамически.

### **8. Это сложно?**

Нет, это простой механизм «ключ → функция». Мы просто вынесли его в удобную структуру, чтобы не писать длинных цепочек if/elif.

### **9. Почему не if/elif?**

У нас более 40 команд. Ветка if/elif стала бы огромной и трудночитаемой. Registry делает систему чистой: каждая команда существует как отдельный модуль логики.

### **10. Как проверяются аргументы?**

В `validate_args()` хранится минимальное количество аргументов (`min_args`). Если пользователь передал меньше — поднимается IndexError, который затем перехватывается декоратором ошибок.

### **11. Зачем @input_error?**

Чтобы любые ошибки — ValueError, KeyError, IndexError — превращались в дружелюбные сообщения, а не падали стектрейсом. Это защищает от непредсказуемого поведения.

### **12. Как работает @mutating?**

После успешной команды вызывает `save_storage()`. Если команда вернула ошибку, ничего не сохраняется. Это предотвращает повреждение данных.

### **13. Почему несколько декораторов подряд?**

Каждый выполняет одну задачу: один регистрирует команду, второй обрабатывает ошибки, третий отвечает за сохранение. Это позволяет держать функции команд максимально чистыми.

### **14. Как определяется функция для команды?**

Имя команды из ввода передаётся в Registry, и тот возвращает соответствующую функцию из своего словаря. Дальше команда просто вызывается.

### **15. Что с дубликатами команд?**

Registry отслеживает их: если команда с таким именем уже есть — поднимет RuntimeError. Это предотвращает случайные конфликты.

### **16. Команды автоматически попадают в help?**

Да. Registry хранит help-текст при регистрации. Функция help динамически собирает информацию о доступных командах.

### **17. Зачем секции help?**

Для UX: команды телефонной книги, заметок и системные логически различны. Пользователь сразу видит структуру.

### **18. Как автокомплит связан с Registry?**

CLI запрашивает у Registry список команд и передаёт его в автокомплит. Когда пользователь набирает первые символы — предлагаются совпадения.

### **19. Сложно ли добавить команду?**

Минимально: одна функция с декоратором. Она автоматически получает поддержку help, автокомплита, ошибок и автосохранения.

### **20. Где происходит сохранение?**

Внутри @mutating — команда не должна помнить о сохранении. Это уменьшает количество ошибок разработчиков.

### **21. Registry — это мини-фреймворк?**

Да, небольшая реализация паттерна «имя → функция», который используется во многих CLI и web-фреймворках.

### **22. Почему команды получают storage, если за сохранение отвечает @mutating?**

Команды получают storage, чтобы иметь доступ к данным: находить контакты, изменять записи, добавлять телефоны, редактировать заметки и т.д. Декоратор @mutating занимается только сохранением результата, но он не хранит внутри себя ссылку на хранилище. Чтобы и команда, и декоратор работали с одной и той же структурой данных, storage передаётся как аргумент в команду и затем используется декоратором.

---

# III. Модели данных (5 вопросов)

### **23. Почему валидация — в моделях?**

Так все данные гарантированно корректны, независимо от интерфейса. Это защищает приложение от невалидных значений.

### **24. Как обрабатываются неверные значения?**

Сеттеры проверяют формат. Неверный формат вызывает ValueError, а input_error превращает его в аккуратное сообщение.

### **25. Что если добавить существующий номер телефона?**

Record проверяет наличие номера в своём списке. Если он уже есть — команда сообщает пользователю об этом.

### **26. Как устроен поиск контактов?**

Поиск выполняется командой find-contact и основан на методе AddressBook.search(). Запрос приводится к lower-case, затем для каждого контакта формируется список строковых полей: имя, телефоны, email, адрес и дата рождения. Алгоритм проверяет, встречается ли подстрока запроса в любом из этих полей; при первом совпадении контакт добавляется в результаты. Порядок полей фиксирован, но поиск прекращается на первом успешном совпадении.

### **27. Как обрабатывается день рождения 29 февраля?**

Если год невисокосный, дата сдвигается на 1 марта. Это встроенная логика в модели Record.

---

# IV. Storage (4 вопроса)

### **28. Почему выбрали pickle?**

Он сериализует Python-объекты без дополнительного кода. Это оптимально на уровне учебного проекта. При необходимости легко перейти на JSON или БД.

### **29. Что если файл повреждён?**

load_storage() безопасно создаёт новое хранилище, если pickle нельзя прочитать. Приложение не падает.

### **30. Когда происходит автосохранение?**

Автосохранение выполняется декоратором @mutating только после успешного завершения команды, то есть когда функция не вернула ошибку и не сгенерировала исключение. Если во время выполнения возник ValueError, KeyError, IndexError (перехватываемые @input_error) или команда вернула специальное значение "__EXIT__", — сохранение не происходит. Таким образом, данные обновляются только при корректных изменениях, что исключает повреждение хранилища при ошибках пользователя.

### **31. Общее ли хранилище?**

Да. Объект Storage создаётся один раз при запуске CLI (через load_storage()) и хранится в одном месте. Во все команды передаётся ссылка на этот же объект, поэтому они работают с общей, единой копией данных.

---

# V. UX (3 вопроса)

### **32. Зачем цвета и какие именно используются?**

Цвета помогают быстро различать типы сообщений. Мы используем библиотеку colorama, которая гарантирует корректную работу цветов в Windows, macOS и Linux. Цветовое кодирование следующее:

Красный (Fore.RED) — ошибки и некорректный ввод.

Зелёный (Fore.GREEN) — успешные операции (например, добавление или редактирование).

Голубой/Синий (Fore.CYAN / Fore.BLUE) — системные сообщения, справка, результаты поиска.

Жёлтый (Fore.YELLOW) — предупреждения или информационные подсказки.

Фиолетовый (Fore.MAGENTA) — теги в заметках, чтобы визуально отделить их от текста.

Такое распределение делает интерфейс консоли визуально структурированным — пользователь мгновенно понимает характер сообщения по цвету.

### **33. Зачем автокомплит?**

Автокомплит реализован через prompt_toolkit и подсказывает возможные команды и имена контактов на основе текущего ввода. Это снижает количество синтаксических ошибок и ускоряет работу.

### **34. Зачем секции help?**

Секции формируются автоматически на основе параметра section, который указывается при регистрации команды в декораторе @REG.register. Registry группирует команды по этим секциям — например, PHONEBOOK, NOTES и SYSTEM — и затем динамически собирает help так, чтобы команды в каждой категории отображались вместе. Это делает справку структурированной и позволяет пользователю быстро находить нужные команды.

### **35. Как выводятся длинные данные, такие как текст заметки?**
Длинные тексты (например, содержимое заметок) выводятся в исходном виде с сохранением переносов строк. Форматирование выполняется через единый шаблон отображения: каждая заметка выводится блоком, где сначала показывается заголовок, затем тело заметки, а после — теги. Разделитель (SEPARATOR) используется только между разными сущностями, чтобы длинный текст не «сливался» со следующей записью. Благодаря этому даже большие тексты остаются визуально понятными.

### **36. Как в UX учтены ошибки пользователя?**
Ошибки перехватываются @input_error, поэтому пользователь получает краткое и понятное сообщение вместо технического стектрейса. Для визуального разграничения используются цвета: ошибки — красным, предупреждения — жёлтым, нейтральные подсказки — голубым. Это делает взаимодействие предсказуемым и понятным.


---

# VI. DX — удобство для разработчиков (4 вопроса)

### **37. Почему низкий порог входа?**

Потому что структура проекта простая и модули небольшие. Новый разработчик видит, куда именно нужно добавлять новую функцию.

### **38. Как избегали конфликтов?**

Роли чётко разделены: один человек занимался автокомплитом, другой — цветами, третий — архитектурой. Модули мало пересекаются.

---

# VII. Работа с контактами (расширено, 10 вопросов)

### **39. Как ищется контакт по имени?**

Имена хранятся в lower-case как ключи в AddressBook. При запросе имя приводится к тому же формату — так поиск всегда надёжен.

### **40. Как ищется телефон внутри контакта?**

Телефоны лежат в списке Phone-объектов. Для поиска просто перебираем их значения (`p.value`).

### **41. Как добавляется телефон?**

Создаётся объект Phone с валидацией формата. Затем Record проверяет, что такого номера ещё нет, и добавляет его.

### **42. Как редактируется телефон?**

Метод edit_phone ищет телефон по старому значению и присваивает ему новое. В этот момент запускается повторная валидация.

### **43. Как удаляется телефон?**

Record перебирает список телефонов, находит совпадение по значению и удаляет его через `pop(i)`. Возвращает True или False.

### **44. Как добавляется адрес?**

Через `rec.set_address(Address(text))`. Адрес просто хранится как строковое поле.

### **45. Как удаляется адрес?**

Метод remove_address устанавливает поле address в None.

### **46. Как добавляется день рождения?**

Birthday парсит дату строго в формате DD.MM.YYYY. Ошибка формата вызывает ValueError.

### **47. Как считаются дни до дня рождения?**

Берём текущую дату, на её основе формируем дату ближайшего ДР. Если в этом году она уже прошла — переносим на следующий.

### **48. Как выводятся ближайшие дни рождения?**

AddressBook группирует ДР: разница в днях → список контактов. Записи сортируются по имени.

---

# VIII. Работа с заметками (расширено, 10 вопросов)

### **49. Как добавляется заметка?**

Создаётся Note(title, text). Title (в нижнем регистре) используется как ключ в NoteBook.

### **50. Как редактируется текст заметки?**

Команда меняет поле note.text. Проверяется, что текст не пустой.

### **51. Как добавляются теги?**

Метод add_tags приводит каждый тег к нижнему регистру и добавляет в set — дубликатов не будет.

### **52. Как удаляются теги?**

Метод remove_tag ищет тег в множестве и при наличии удаляет.

### **53. Как удаляется заметка?**

NoteBook.remove(title) удаляет запись по ключу.

###
