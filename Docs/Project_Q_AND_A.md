# Повна Q&A-шпаргалка по проєкту

---

# I. Архітектура (6 питань)

### **1. Навіщо ви розбили проєкт на окремі модулі?**

Щоб знизити зв'язаність та зробити код читабельним. Кожен модуль відповідає за свою частину логіки: моделі — за дані, команди — за бізнес-логіку, CLI — за ввід/вивід, storage — за збереження. Це полегшує підтримку та дозволяє будь-якому розробнику швидко орієнтуватися.

### **2. Головна перевага архітектури?**

Компоненти незалежні. Наприклад, можна замінити pickle-сховище на JSON або SQLite, не змінюючи команди. Або переписати CLI на веб-інтерфейс — і решта логіки продовжить працювати.

### **3. Які залежності між модулями?**

Залежності строго односпрямовані: CLI → Registry → Commands → Models → Storage → Config. Це виключає циклічні імпорти та робить систему передбачуваною.

### **4. Чому CLI такий тонкий?**

CLI займається лише парсингом рядка та виведенням результату. Логіка винесена в команди, а правила роботи з даними — у моделі. Такий підхід робить інтерфейс легко замінним.

### **5. Де точка розширення застосунку?**

Команди. Будь-яку нову функцію — від експорту даних до SMS-нагадувань — можна реалізувати однією функцією з декоратором. Решта архітектури вже готова це підтримати.

### **6. Як би ви додали Telegram-бота?**

Я б залишив команди та моделі без змін. Бот просто приймає текст користувача, парсить аргументи та викликає ті самі функції команд. Архітектура дозволяє це без переробок.

---

# II. CommandRegistry (15 питань)

### **7. Як реєструються команди?**

Через `@REG.register`. При реєстрації ім'я команди додається до словника реєстру як ключ, а посилання на функцію — як значення. Це дозволяє обробляти команди динамічно.

### **8. Це складно?**

Ні, це простий механізм «ключ → функція». Ми просто винесли його в зручну структуру, щоб не писати довгих ланцюжків if/elif.

### **9. Чому не if/elif?**

У нас понад 40 команд. Гілка if/elif стала б величезною та важкочитаною. Registry робить систему чистою: кожна команда існує як окремий модуль логіки.

### **10. Як перевіряються аргументи?**

У `validate_args()` зберігається мінімальна кількість аргументів (`min_args`). Якщо користувач передав менше — піднімається IndexError, який потім перехоплюється декоратором помилок.

### **11. Навіщо @input_error?**

Щоб будь-які помилки — ValueError, KeyError, IndexError — перетворювалися на дружні повідомлення, а не падали стектрейсом. Це захищає від непередбачуваної поведінки.

### **12. Як працює @mutating?**

Після успішної команди викликає `save_storage()`. Якщо команда повернула помилку, нічого не зберігається. Це запобігає пошкодженню даних.

### **13. Чому кілька декораторів підряд?**

Кожен виконує одне завдання: один реєструє команду, другий обробляє помилки, третій відповідає за збереження. Це дозволяє тримати функції команд максимально чистими.

### **14. Як визначається функція для команди?**

Ім'я команди з введення передається в Registry, і той повертає відповідну функцію зі свого словника. Далі команда просто викликається.

### **15. Що з дублікатами команд?**

Registry відстежує їх: якщо команда з таким ім'ям вже є — підніме RuntimeError. Це запобігає випадковим конфліктам.

### **16. Команди автоматично потрапляють у help?**

Так. Registry зберігає help-текст при реєстрації. Функція help динамічно збирає інформацію про доступні команди.

### **17. Навіщо секції help?**

Для UX: команди телефонної книги, нотаток та системні логічно відрізняються. Користувач одразу бачить структуру.

### **18. Як автокомпліт пов'язаний з Registry?**

CLI запитує у Registry список команд та передає його в автокомпліт. Коли користувач набирає перші символи — пропонуються збіги.

### **19. Складно додати команду?**

Мінімально: одна функція з декоратором. Вона автоматично отримує підтримку help, автокомпліта, помилок та автозбереження.

### **20. Де відбувається збереження?**

Всередині @mutating — команда не повинна пам'ятати про збереження. Це зменшує кількість помилок розробників.

### **21. Registry — це міні-фреймворк?**

Так, невелика реалізація патерну «ім'я → функція», який використовується у багатьох CLI та web-фреймворках.

### **22. Чому команди отримують storage, якщо за збереження відповідає @mutating?**

Команди отримують storage, щоб мати доступ до даних: знаходити контакти, змінювати записи, додавати телефони, редагувати нотатки тощо. Декоратор @mutating займається лише збереженням результату, але він не зберігає всередині себе посилання на сховище. Щоб і команда, і декоратор працювали з однією і тією самою структурою даних, storage передається як аргумент у команду і потім використовується декоратором.

---

# III. Моделі даних (5 питань)

### **23. Чому валідація — у моделях?**

Так усі дані гарантовано коректні, незалежно від інтерфейсу. Це захищає застосунок від невалідних значень.

### **24. Як обробляються неправильні значення?**

Сетери перевіряють формат. Неправильний формат викликає ValueError, а input_error перетворює його на акуратне повідомлення.

### **25. Що якщо додати існуючий номер телефону?**

Record перевіряє наявність номера у своєму списку. Якщо він вже є — команда повідомляє користувачу про це.

### **26. Як влаштований пошук контактів?**

Пошук виконується командою find-contact та базується на методі AddressBook.search(). Запит приводиться до lower-case, потім для кожного контакту формується список рядкових полів: ім'я, телефони, email, адреса та дата народження. Алгоритм перевіряє, чи зустрічається підрядок запиту в будь-якому з цих полів; при першому збігу контакт додається до результатів. Порядок полів фіксований, але пошук припиняється на першому успішному збігу.

### **27. Як обробляється день народження 29 лютого?**

Якщо рік невисокосний, дата зміщується на 1 березня. Це вбудована логіка в моделі Record.

---

# IV. Storage (4 питання)

### **28. Чому обрали pickle?**

Він серіалізує Python-об'єкти без додаткового коду. Це оптимально на рівні навчального проєкту. При необхідності легко перейти на JSON або БД.

### **29. Що якщо файл пошкоджений?**

load_storage() безпечно створює нове сховище, якщо pickle неможливо прочитати. Застосунок не падає.

### **30. Коли відбувається автозбереження?**

Автозбереження виконується декоратором @mutating тільки після успішного завершення команди, тобто коли функція не повернула помилку і не згенерувала виняток. Якщо під час виконання виник ValueError, KeyError, IndexError (що перехоплюються @input_error) або команда повернула спеціальне значення "__EXIT__", — збереження не відбувається. Таким чином, дані оновлюються тільки при коректних змінах, що виключає пошкодження сховища при помилках користувача.

### **31. Чи спільне сховище?**

Так. Об'єкт Storage створюється один раз при запуску CLI (через load_storage()) і зберігається в одному місці. До всіх команд передається посилання на цей самий об'єкт, тому вони працюють зі спільною, єдиною копією даних.

---

# V. UX (3 питання)

### **32. Навіщо кольори і які саме використовуються?**

Кольори допомагають швидко розрізняти типи повідомлень. Ми використовуємо бібліотеку colorama, яка гарантує коректну роботу кольорів у Windows, macOS та Linux. Кольорове кодування наступне:

Червоний (Fore.RED) — помилки та некоректне введення.

Зелений (Fore.GREEN) — успішні операції (наприклад, додавання або редагування).

Блакитний/Синій (Fore.CYAN / Fore.BLUE) — системні повідомлення, довідка, результати пошуку.

Жовтий (Fore.YELLOW) — попередження або інформаційні підказки.

Фіолетовий (Fore.MAGENTA) — теги у нотатках, щоб візуально відділити їх від тексту.

Такий розподіл робить інтерфейс консолі візуально структурованим — користувач миттєво розуміє характер повідомлення за кольором.

### **33. Навіщо автокомпліт?**

Автокомпліт реалізований через prompt_toolkit та підказує можливі команди та імена контактів на основі поточного введення. Це знижує кількість синтаксичних помилок та прискорює роботу.

### **34. Навіщо секції help?**

Секції формуються автоматично на основі параметра section, який вказується при реєстрації команди в декораторі @REG.register. Registry групує команди за цими секціями — наприклад, PHONEBOOK, NOTES та SYSTEM — і потім динамічно збирає help так, щоб команди в кожній категорії відображалися разом. Це робить довідку структурованою та дозволяє користувачу швидко знаходити потрібні команди.

### **35. Як виводяться довгі дані, такі як текст нотатки?**
Довгі тексти (наприклад, вміст нотаток) виводяться у вихідному вигляді зі збереженням переносів рядків. Форматування виконується через єдиний шаблон відображення: кожна нотатка виводиться блоком, де спочатку показується заголовок, потім тіло нотатки, а після — теги. Роздільник (SEPARATOR) використовується тільки між різними сутностями, щоб довгий текст не «зливався» з наступним записом. Завдяки цьому навіть великі тексти залишаються візуально зрозумілими.

### **36. Як у UX враховані помилки користувача?**
Помилки перехоплюються @input_error, тому користувач отримує коротке та зрозуміле повідомлення замість технічного стектрейсу. Для візуального розмежування використовуються кольори: помилки — червоним, попередження — жовтим, нейтральні підказки — блакитним. Це робить взаємодію передбачуваною та зрозумілою.


---

# VI. DX — зручність для розробників (4 питання)

### **37. Чому низький поріг входу?**

Тому що структура проєкту проста і модулі невеликі. Новий розробник бачить, куди саме потрібно додавати нову функцію.

### **38. Як уникали конфліктів?**

Ролі чітко розділені: одна людина займалася автокомплітом, інша — кольорами, третя — архітектурою. Модулі мало перетинаються.

---

# VII. Робота з контактами (розширено, 10 питань)

### **39. Як шукається контакт за іменем?**

Імена зберігаються в lower-case як ключі в AddressBook. При запиті ім'я приводиться до того самого формату — так пошук завжди надійний.

### **40. Як шукається телефон всередині контакту?**

Телефони лежать у списку Phone-об'єктів. Для пошуку просто перебираємо їх значення (`p.value`).

### **41. Як додається телефон?**

Створюється об'єкт Phone з валідацією формату. Потім Record перевіряє, що такого номера ще немає, і додає його.

### **42. Як редагується телефон?**

Метод edit_phone шукає телефон за старим значенням та присвоює йому нове. В цей момент запускається повторна валідація.

### **43. Як видаляється телефон?**

Record перебирає список телефонів, знаходить збіг за значенням та видаляє його через `pop(i)`. Повертає True або False.

### **44. Як додається адреса?**

Через `rec.set_address(Address(text))`. Адреса просто зберігається як рядкове поле.

### **45. Як видаляється адреса?**

Метод remove_address встановлює поле address в None.

### **46. Як додається день народження?**

Birthday парсить дату строго у форматі DD.MM.YYYY. Помилка формату викликає ValueError.

### **47. Як рахуються дні до дня народження?**

Беремо поточну дату, на її основі формуємо дату найближчого ДН. Якщо в цьому році вона вже пройшла — переносимо на наступний.

### **48. Як виводяться найближчі дні народження?**

AddressBook групує ДН: різниця в днях → список контактів. Записи сортуються за іменем.

---

# VIII. Робота з нотатками (розширено, 10 питань)

### **49. Як додається нотатка?**

Створюється Note(title, text). Title (у нижньому регістрі) використовується як ключ у NoteBook.

### **50. Як редагується текст нотатки?**

Команда змінює поле note.text. Перевіряється, що текст не порожній.

### **51. Як додаються теги?**

Метод add_tags приводить кожен тег до нижнього регістру та додає в set — дублікатів не буде.

### **52. Як видаляються теги?**

Метод remove_tag шукає тег у множині та при наявності видаляє.

### **53. Як видаляється нотатка?**

NoteBook.remove(title) видаляє запис за ключем.
